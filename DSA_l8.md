Hash-таблицы
=========

>struct Node
{
    int key;
    char inf;
} T[N];

Варианты поиска:
-----
    1. Последовательный поиск по ключу  O(N)
    2. Бинарное дерево поиска   O(log2(N))
    3. Бинарный (делением пополам) поиск применяется к упорядочиванию таблицы  
    4. Хэширование (от англ. to hash - крушить) или рассеяная память

k - искомый ключ
f(k) -адрес расположения записи с данным ключом k

Идея хэширования состоит в вычислении по ключу хэш адреса h(k) и использование его для проведения поиска.
События при котором событие Ki и Kj имеют одинаковые Hash функции называются коллизией.

Задача программиста при исколзовании класса хэширования:
-----------
    1. Выбрать хэщ функцию h(k)
    2. Выбрать способ размещения коллизий

Хорошая хэш-функция должна удовлетворять следующим требованям:
    * Вычисление должно выполнятся очень быстро
    * Должно минимизировать колисество коллизий

Хэширование искользуется в двух областях:
    * Для поиска информации
    * Для криптографии (MD5) 

Типы хэширования:
--------
**1.Метод остаточного деления** 
        h(k) = k mod M
        0<=h(k)<M
        М - должно быть простым числом
Пример:
>   M = 1000 = 10^3
    k1 = 478125 mod 1000 = 125
    k2 = 810125 mod 1000 = 125
    k3 = 900125 mod 1000 = 125

**2.Метод умножения**
        * Представим дробь в виде двоичного числа
        * Возьмём некоторое значение p
        * Умножим p*k 
        * Возьмём часть этого произведения
        * Возьмём умножим на m и берём целую часть
    h(k)=[M*(p*k)mod 1)]

**3. Метод среднего квадрата**
        * Возводим k^2(двоичное представление к) и за хэш адрес берём середину этого числа
    k^2 = 5[2]5, где 2 - хэш-адрес

**4.Метод**
    * Ключ разбрасывается n-частей потом эти части арифметически или алгебраически складываются.
    Метод работает плохо, когда либо слева, либо справа много нулей.
    k = 271304 -> 271+305 = 575 = h(k)
    Метод может использоваться для составных ключей

**5.**
    h(k) = (h2(x1)+h2(x2)+...+h1(x1))mod M
    hj - независимые хэш функции

Методы разрешения коллизий:
-----
**1. Метод цепочек**
    **1.1.** *Таблицы с внешними цепочками (раздельные цепочки)*
    **1.2.** *Внутренние цепочки (сросшиеся)*
        Применяется, если известно, что таблица в процессе её использования будет оставаться почти неизменной.
**2. Метод открытых адресов**
    Идея метода заключается в последовательном просмотре различных записей в таблице согласно сформулированному правилу, до тех пор, пока не будет найден ключ k или пустая позиция.
    **2.1.** *Линейное исследования*
        h(k), h(k)-1, h(k)-2,..., 0, M-1, M-2,..., h(k)+1
        Циклически проверяются ячейки
    **2.2** *Двойное (повторное) хэширование*
        В данном способе исползуются две хэш-фукции h1(k) и h2(k).
        h1(k) = k mod M
        h2(k) = 1+(k mod (M-1)), h2(k) = 1+(k mod (M-2))
        выбираем M и M-2 ()

        h2(k) = {1, если h1(k)>0, M-h1(k),  если h1(k)>0}       