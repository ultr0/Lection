Структуры и алгоритмы обработки данных. Лекция 2
=============

<div>
<div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><div><u>Указатели.</u><br/>
Программный уровень :</div><ul><li>Переменные &lt;-&gt;Имя и значение</li></ul><div>Машинный уровень :</div><ul><li>Участок памяти &lt;-&gt;адрес памяти &lt;-&gt;содержание</li></ul><div><b>Указатель</b> -  переменная,  хранящую в себе адрес памяти.
<div><br/></div>
Указатели в C++:</div><ol><li>Указатель на объект. (содержит адрес области памяти  в которой хранятся данные определённого типа ) //тип*идентификатор</li><li>Указатель на void. (применяется в тех случаях,  когда не определён тип объекта,  адрес которого придётся хранить) //void*идентификатор</li></ol><div>

  Int *ptr1, *ptr2 ;
  ...
  Void *ptr=ptr1;
  Ptr2=(int *)ptr; //явное преобразование к типу int * (указатель на int)
  ..
  Double *fptr;
  Double *pointer =(double*) ptr;

   3. Указатель на функцию.

<div><br/></div><u><b><i>Ссылки</i></b></u><br/>
Ссылка является синонимом имени.<br/>

  Тип &  имя = инициализация ;
  Int kol;
  Int & pal=kol;
  Правила при работе  с ссылками

<ol><li>Ссылка явно инициализируется в описании</li><li>После инициализации ссылке не должна быть присвоена другая переменная</li><li>Тип ссылки должен совпадать с типом величины,  на которую ссылается.</li><li>Не разрешается определять указатели на ссылки,  массив ссылок и ссылки на ссылки</li></ol><div><br/><b>Основные статические структуры данных.</b><br/></div><ul><li><span style="background-color:rgb(255, 250, 165);-evernote-highlight:true;">Структура</span></li></ul><div>Объединяет элементы разных типов. Эти элементы называются полями и  могут быть определены любым типом,  кроме типа структуры,  но могут быть указателями на него.
<div><br/></div>

  Struct Pr
  {
  Int a; //4 byte
  Double b; //8 byte
  Short c; //2 byte
  } Primer;

<div><img src="img/DSA_l2.png" type="image/png" height="624" style="cursor: default;" width="1280"/></div><div><br/>
Поля хранятся последовательно.<br/>
Выравнивание начальной части структуры является максимальным выравниванием любого отдельного поля. Каждое поле внутри структуры размещается в соответствие с своим выравниванием,  для чего может потребовать неявное внутреннее заполнение. Размер структуры должен быть целым числом,  кратным,  его выравниванию,  для этого может потребоваться дополнение после последнего поля.<br/></div><ul><li><span style="background-color:rgb(255, 250, 165);-evernote-highlight:true;"><span style="background-color:rgb(255, 250, 165);-evernote-highlight:true;">Объединение</span></span></li></ul><div>

  Union  Pr
  {
  Int a; //4 byte
  Double b; //8 byte
  Short c; //2 byte
  };
  ...
  Pr AB;
  В каждый момент времени вы можете работать с каждым значением хранения.
  AB.a=5;
  AB.b=37;//удалит значение 5
  AB.c=7;

<ul><li><span style="background-color:rgb(255, 250, 165);-evernote-highlight:true;">Вектор</span></li></ul><div>Размещается в одной сплошной области памяти.  Все его элементы имеют одинаковую длину и размещаются последовательно один за другим.  Доступ к элементам вектора осуществляется через  индекс.<br/>
Для манипулирования данными,  хранимых вектором требуется управляющая информация,  определяющая адрес начала вектора,  длину или тип его элемента,  количество элементов,  индекс начального и конечного элемента.</div><div>Для хранения управляющей информации создаётся дескриптор( описатель)  вектора:</div><ul><li>Адрес начала вектора a0=LOC(A[M]</li><li>Длина элемента</li><li>Индекс начального элемента M</li><li>Индекс конечного элемента N</li></ul><div>Адрес элемента с индексом I<br/>
LOC (A[I]) =LOC(A[M])+(I-M)*L<br/>
При нумерации от 0<br/>
LOC (A[I]) =LOC(A[0]) +(I-M)*L<br/></div><div>Все элементы хранятся в смежных участках памяти подряд. Два размещения массива в памяти:</div><ul><li>По строкам (элементы в памяти располагаются строка за строкой,  при обращении массива чаще всего меняется последний индекс)</li><li>По столбцам (элементы располагаются в памяти последовательно столбец за столбцом, чаще всего меняется первый индекс)</li></ul><div><br/><u>Пример</u>. I, J, нумерация с нуля.<br/>

  LOC(A[I][J]) =a0+a1*I+a2*J
  //a0,a1,a2 -  const.
  a0= LOC(A[0][0])//N1-максимадьный индекс по строкам
  a1= L*(N2+1) //количество столбцов
  a2 =L

<div><br/></div>
Определение адреса элемента k-мерного массива<br/>

  LOC(A[I1][J2].. [Ik] ) = LOC(A[0][0].. [0] )+ L*(n2+1)*(n3+1)*...*(nk+1)*I1+ L*(n2+1)*(n3+1)*...*(nk+1)*I2+ L*(n2+1)*(n3+1)*...*(nk+1)*Ik=LOC(A[0][0].. [0] )+summFrom1Tok ar*Ir.

<img src="img/DSA_lI2.jpeg" type="image/jpeg" style="cursor: default;"/></div></div>
</div>